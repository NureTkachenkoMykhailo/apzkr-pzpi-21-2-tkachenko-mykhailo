Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для відстеження тренувань і безпеки на гірськолижному курорті

Студент гр. ПЗПІ-21-2	__________________ Ткаченко М. Ю.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук               Кафедра програмної інженерії____
Спеціальність 121 – Інженерія програмного забезпечення_______________
Курс	3	Семестр	6_______________
Навчальна дисципліна Архітектура програмного забезпечення


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Ткаченко Михайлу Юрійовичу
1.	Тема роботи: «Програмна система для відстеження тренувань і безпеки на гірськолижному курорті»	
2.	Термін узгодження завдання курсової роботи «26» лютого 2024 р.
3.	Термін здачі студентом закінченої роботи «27» серпня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
оригінальність, потенціал монетизації, актуальність проблематики, орієнтація на широке коло користувачів, масштабованість та міжнародна підтримка. Система повинна включати серверну та клієнтську частини, мобільний застосунок, а також застосунок для IoT або Smart Device. 
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз та концептуальне моделювання предметної області, опис розробки серверної частини, опис розробки IoT застосунку, опис розробки веб клієнтської частини, опис розробки мобільної частини системи, висновки, перелік джерел посилання, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма прецедентів, ER-модель даних, UML діаграма розгортання, схема ІоТ девайсу	
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	31.03.2024	Виконано
2	Проектування програмного
проекту	01.05.2024	Виконано
3	Кодування програмного проекту	18.08.2024	Виконано
4	Оформлення пояснювальної
записки	21.08.2024	Виконано
5	Захист курсової роботи	27.08.2024	

Дата видачі завдання «31» березня 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________            Ткаченко М.Ю.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка: 52с., 7 рис., 2 додатку, 7 джерел.
ГОРИ, ГІРСЬКОЛИЖНИЙ, КУРОРОРТ, АВТОМАТИЗАЦІЯ, АРХІТЕКТУРА.
Метою проекту є розробка програмної системи для автоматизації управління та відстеження тренувань та безпеки на гірськолижному курорті.
Основний стек технологій це PostgreSql як загальна СУБД для всіх схем бази даних, PqAdmin4 як утиліта для перегляду та ручного редагування даних в базі даних, ASP NET Core Web Api для реалізації RESTful API серверу, контролеру ESP32, Angular, .NET MAUI.
Програмна система дозволяє користувачам керувати трасами, інструкторами, інвентарями, тренуваннями та бронюванням.
Траса складається з секцій, кожна сесія має датчики погоди, які шлють моніторінгові дані та в разі зміни рівню небезпеки сервер змінює статус секції відповідно до новоотриманих даних з датчику відповідної секції.
 

ЗМІСТ


ВСТУП	7
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ	8
ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Бізнес-можливості	8
1.2 Аналіз існуючих аналогів	8
1.3 Головна функціональність	9
1.4 Робоче середовище	10
2 ОПИС РОЗРОБКИ СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ	11
2.1 Побудова ER-моделі даних	11
2.2 Опис архітектури серверної частини системи	12
2.3 Опис взаємодії з іншими частинами системи	14
2.4 Опис структури коду серверної частини системи	14
2.5 Специфікація REST	15
3 ОПИС РОЗРОБКИ IoT ЗАСТОСУНКУ	17
3.1 Концептуальне моделювання застосунку	17
3.2 Обгрунтування архітектурних рішень	17
3.3 Опис використаних технологій	18
3.4 Опис результатів розробки застосунку	18
4 ОПИС РОЗРОБКИ ВЕБ КЛІЄНТСЬКОЇ ЧАСТИНИ СИСТЕМИ	19
4.1 Концептуальне моделювання застосунку	19
4.2 Обгрунтування архітектурних рішень	19
4.3 Опис використаних технологій	20
4.4 Опис результатів розробки клієнтської частини системи	20
4.5 Опис результатів тестування клієнтської частини системи	20
5 ОПИС РОЗРОБКИ МОБІЛЬНОЇ ЧАСТИНИ СИСТЕМИ	21
5.1 Концептуальне моделювання застосунку	21
5.2 Обгрунтування архітектурних рішень	21
5.3 Опис використаних технологій	22
5.4 Опис результатів розробки мобільного застосунку	22
5.5 Опис результатів тестування клієнтської частини системи	23
ВИСНОВКИ	24
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ	25
ДОДАТОК А	26
А.1 UML діаграма прецедентів	26
А.2 ER-модель даних	27
А.4 Діаграма пакетів	29
А.5 UML діаграма діяльності IoT девайсу	30
А.6 Діаграма взаємодії	31
А.7 Схема фізичної моделі IoT девайсу	32
ДОДАТОК Б	33
Б.1 Стартовий файл серверної частини	33
Б.2 Код сервісу IdentityService	34
Б.3 Код базового репозиторію	40
Б.4 Код ініціалізації IoT девайсу	44
Б.5 Конфігурація IoT девайсу	46
Б.6 Код ініціалізації веб клієнту	46
Б.7 Код ініціалізації адміністративного модуля	47
Б.8 Код ініціалізації мобільного клієнту	49
Б.9 Код глобальних налаштувань мобільного застосунку	50
Б.9 Код головної моделі	50

 
ВСТУП


У сфері відпочинку та розваг, особливо на гірськолижних курортах, безпека і високий рівень обслуговування є критично важливими факторами для забезпечення комфорту та захисту гостей. Ефективне управління тренуваннями персоналу, моніторинг рівня підготовки та контроль за дотриманням стандартів безпеки є ключовими аспектами, які сприяють підвищенню якості обслуговування та зменшенню ризиків. У цьому контексті виникає необхідність у впровадженні інноваційного програмного забезпечення, яке дозволяє комплексно оптимізувати заходи безпеки на гірськолижних курортах. Така система може забезпечити більш злагоджену роботу, зменшити кількість аварій та надзвичайних ситуацій, підвищуючи задоволеність клієнтів. Окрім цього, автоматизація і централізація цих процесів допоможуть курортам зберігати конкурентоспроможність на ринку, залучаючи більше клієнтів, і, як наслідок, збільшуючи дохід та репутацію закладу.
Отже, задачею є розробка системи автоматизації управління гірськолижним курортом та заходами безпеки на ньому для ефективного надання послуг для безпечного відпочинку туристів.
Результатом роботи стала система управління гірськолижним курортом, яка складається з таких частин як сервер, веб клієнт, IoT та мобільний додаток.
Для розробки системи використовувались наступні технології та утиліти як: мови програмування C#, Typescript, CSS, HTML; фреймворки ASP.NET Core, Angular, MAUI; середовища розробки JetBrains Rider, JetBrains Webstorm; СУБД PostgreSql та допоміжні технології зокрема ORM EF Core та інші.
 

1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ
ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-можливості


Система для відстеження тренувань і безпеки на гірськолижному курорті призначена для корпоративних клієнтів у гірськолижній галузі для автоматизації бізнес-процесів, а для звичайних гостей курортів – забезпечення комфортних умов та продуктивного і безпечного тренування. Продукт дає можливість покращення управління персоналом та забезпечення безпеки гостей. Наразі в багатьох курортах немає централізованої системи для відстеження тренувань та безпеки, тому це може бути перспективною нішею на ринку. Зосередження на розвитку системи в місцях з обмеженим доступом до тренувань та безпеки дозволяє не лише підвищувати рівень ефективності та безпеки на курорті, але і привертати нових клієнтів, збільшуючи прибуток.


1.2 Аналіз існуючих аналогів


На ринку існують компанії, які також надаються послуги в сфері автоматизації гірнолижних курортів, такі як наприклад Inntopia, яка пропонує інтегровані програмні рішення для гірськолижних курортів, включаючи системи бронювання, квиткові платформи, аналітику та інші інструменти для управління різними аспектами курортного бізнесу, а також MountainGuard – компанія, яка спеціалізується на розробці та впровадженні систем безпеки для гірськолижних курортів, включаючи системи відеоспостереження, системи трекінгу гірських трас, системи аварійного сповіщення та інші технологічні рішення для підвищення безпеки на курортах.


1.3 Головна функціональність


Розширена система управління гірськолижним курортом передбачає кілька ключових функцій, орієнтованих на забезпечення зручності, безпеки та залучення клієнтів. Адміністратор має розширені права доступу до основних ресурсів системи, включаючи управління трасами, тренуваннями, моніторинг безпеки та інші аспекти курорту. Він може аналізувати дані для оптимізації роботи та покращення послуг, однак адміністратор не має можливості здійснювати бронювання тренувань. Це завдання відведене гостям.
Інструктор зосереджується на управлінні тренуваннями, створюючи та оновлюючи інформацію про сесії, які доступні для клієнтів. Він має змогу налаштовувати розклад тренувань, слідкувати за станом трас та надавати рекомендації гостям, базуючись на їхньому рівні підготовки та безпеці на курорті.
Гості курорту мають доступ до функцій перегляду інформації про тренування, можливості бронювання сесій та отримання сповіщень про актуальні умови на трасах. Система підтримує актуальну інформацію про стан трас, розташування інструкторів і гірськолижників у реальному часі, що дозволяє ефективно планувати свій відпочинок.



1.4 Робоче середовище


Система буде розроблена з використанням мови програмування C# і TypeScript. Ці мови дозволять створювати ефективний та надійний код для різних складних функцій системи.
Для зберігання даних  системи використовуватиметься PostgreSQL, що забезпечить надійність, швидкодію та гнучкість у взаємодії з даними. Адміністрування бази даних буде здійснюватися через інтерфейс PgAdmin4.
Для розробки серверної частини додатку буде використаний фреймворк ASP.NET Core. Це забезпечить високу ефективність, масштабованість та безпеку системи за допомогою зручних елементів керування доступом до даних та політик авторизації.
Для створення веб-інтерфейсу додатку буде використано фреймворк Angular, який забезпечить швидкість розробки та динамічність веб-сторінок. Використовуватиметься JavaScript, TypeScript, HTML, CSS для створення інтерактивних інтерфейсів.
Для розробки мобільного додатку буде використовуватись технологія MAUI (Multi-platform App UI) з використанням мови програмування C#. Ця технологія дозволить створювати крос-платформові додатки для різних мобільних платформ з використанням одного коду.
Для реалізації IoT-частини проекту буде використовуватись емулятор Wokwi та мова Python для написання бізнес логіки моніторингу умов на секціях траси.
Максимально припустимий час відповіді серверу визначено 5 секунд. За цілісність та атомарність даних відповідає централізоване сховище а також шина даних для розподілу та розповсюдження інформації через всю систему.


2 ОПИС РОЗРОБКИ СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
2.1 Побудова ER-моделі даних


Для побудови ефективної системи треба спочатку розробити головні галузеві типи даних, які будуть відповідати за представлення тих чи інших галузевих понять. Для розробки серверної частини використовується мова С# (фреймворк ASP.NET Core), тому сутності в системі будуть представлені класами мови С#.
Головними сутностями системи є користувач, траса, тренування та бронювання.
Тип «Користувач» відповідає за загальне представлення користувача в системі, незважаючі на рівень доступу до системних функцій. Тип має ідентифікатор числового типу, а також загальну інформацію про користувача, таких як мова, пошта, ім’я і тд..
Тип «Адміністратор» є підтипом типу «Користувач» (зв’язок один до одного) та відображає набір додаткових характеристик, які характерні саме для адміністратора, а саме роль адміністратора.
Тип «Інструктор» є підтипом типу «Користувач» (зв’язок один до одного) та відображає набір додаткових характеристик, які характерні саме для інструктора, а саме досвід в тренуваннях і роль інструктора.
Тип «Гість» є підтипом типу «Користувач» (зв’язок один до одного) та відображає набір додаткових характеристик, які характерні саме для гостя, а саме рівень членства та роль гостя.
Тип «Траса» є самостійним типом та представляє поняття траси, має назву траси, первинний ключ і набір секцій траси.
Тип «Секція» є залежним типом від «Траси» (зв’язок один до багатьох), існує тільки в межах траси та представляє поняття секції або регіону з певними відмінностями коефіцієнтів впливу певних типів погоди, має інформацію про базовий рівень небезпеки, викривлення в градусах, первинного ідентифікатора та назви. 
Тип «Тренування» є залежним типом від «Траси» (зв’язок багато до одного) та «Інструктор» (зв’язок багато до одного), бо тренування може проходити лише на трасі і тільки під наглядом інструктора. Тип має первинний ідентифікатор, інформацію про трасу, інструктора, набір «Бронювань» (зв’язок один до багатьох) та набір «Рівнів навичок».
Тип «Рівень навичок» є типом перерахування та містить три значення: початківець, впевнений, професіонал.
Тип «Бронювання» є залежним типом від «Тренування» (зв’язок багато до одного) та «Гість» (зв’язок багато до одного), має первинний ідентифікатор, інформацію про гостя, сесію тренування, дату створення та дату скасування, а також флагове значення «скасований».
Тип «Інвентар» є самостійним типом, представляє поняття інвентарю та має первинний ключ, назву інвентарю і набір предметів інвентарю.
Тип «Предмет інвентарю» є залежним типом від типу «Інвентар» (багато до одного) і існує в межах інвентаря. Має первинний ключ, набір «Тренувань» в яких предмет зарезервовано (зв’язок багато до багатьох), назву а також набір довільних атрибутів, які представлені структурою «Атрибут», яка має назву атрибуту та значення атрибуту.
На основі отриманих даних створили ER-модель даних (рис. А.2)


2.2 Опис архітектури серверної частини системи


Серверна частина є модульною, багатошаровою системою, спроектованою для забезпечення чіткого розподілу відповідальності та підтримуваності. Вона складається з чотирьох основних шарів: Core, Application, Infrastructure та API.
Шар Core визначає основні абстракції бізнес логіки та бізнес-правил, що керують застосунком, а також основні події, які управляють хореографією  застосунку.
Шар Application відповідає за управління логікою застосунку, а також реагування на події, обробку винятків та надання основних сервісів і розширень, які підтримують функціональність застосунку.
Шар Infrastructure зосереджений на технічних аспектах доступу до даних і зберігання, управління взаємодією з базами даних, системами обміну повідомленнями (шини даних) та інтеграцією із зовнішніми сервісами. Це забезпечує, щоб основна логіка залишалася незалежною від деталей збереження даних.
API-шар обробляє зовнішній інтерфейс застосунку, керуючи тим, як клієнти взаємодіють з сервером. Він складається з кількох компонентів, таких як управління залежностями, властивості, атрибути та контролери, які визначають кінцеві точки застосунку. Цей шар також включає розширення для додаткових функцій, фонову обробку і картографування для перетворення даних між шарами. Моделі визначають структури даних, що використовуються API, а опції дозволяють налаштовувати параметри. Шар також містить компоненти для управління токенами та рівнем доступу користувачів. Загальні конфігурації централізовані у файлах, таких як appsettings.json, ApiDefaults.cs.


2.3 Опис взаємодії з іншими частинами системи


Розгортання передбачає встановлення пристроїв IoT, які відстежують погодні умови та передають дані на серверний сервер через Інтернет за допомогою HTTP. Внутрішній сервер, отримує ці дані через визначену кінцеву точку. Отримавши дані, сервер обробляє їх, зберігає в базі даних за допомогою TCP підключення і запускає відповідні події з метаданими іншим компонентам системи. Мобільний додаток, встановлений на пристроях користувачів, зв’язується з внутрішнім сервером через RESTful API, щоб дозволити користувачам робити бронювання та отримувати доступ до даних про погоду. Веб-програма взаємодіє з внутрішнім сервером, щоб забезпечити адміністративні функції та рекламний вміст, також використовуючи безпечний RESTful API. Таким очином отримуємо діаграму розгортання (рис. А.3).


2.4 Опис структури коду серверної частини системи


Головним пакетом системи є Core.Features, це пакет який відповідають за абстракцію бізнес логіки, декларування бізнес правил та головних сутностей.
Рівень бізнес логіки представлено пакетами Application.Services та Application.EventHandling, ці пакети відповідають за виконання бізнес логіки та за оркестрування стану системи.
Рівень взаємодії з даними представлено пакетами Infrastructure.Data, Infrastructure.Repositories, Infrastructure.Services та Infrastructure.Messaging. Ці пакети відповідають за доступ до даних в базі і за публікацію подій наскрізь системи.
Рівень інтерфейсу системи представлено пакетами API.DI та API.Controllers. API.DI - інверсія контроля, API.Controllers – обробка вхідних і вихідних даних з-за поза меж системи. 
Отже, отримуємо наступну діаграму пакетів (рис. А.4).


2.5 Специфікація REST


-	GET /backoffice/inventories - Retrieve all inventories 

-	POST /backoffice/inventories - Create a new inventory 
-	GET /backoffice/inventories/{id} - Retrieve a specific inventory by ID 
-	PUT /backoffice/inventories/{id}/items - Update items in inventory by inventory ID 
-	DELETE /backoffice/inventories/{id}/items/{itemId} - Delete a specific item by item ID from a specific inventory by inventory ID

-	GET /backoffice/tracks - Retrieve all tracks 
-	POST /backoffice/tracks - Create a new track 
-	GET /backoffice/tracks/{id} - Retrieve a specific track by ID 
-	DELETE /backoffice/tracks/{id} - Delete a specific track by ID

-	GET /backoffice/trainings - Retrieve all training sessions 
-	POST /backoffice/trainings - Create a new training session 
-	GET /backoffice/trainings/{id} - Retrieve training session by ID 
-	DELETE /backoffice/trainings/{id} - Delete training session by ID 
-	PUT /backoffice/trainings/{id}/reserve - Reserve training session by ID

-	GET /bookings - Retrieve all bookings
-	GET /bookings/{trainingId} - Retrieve bookings by training ID 
-	PATCH /bookings/{bookingId} - Update booking by booking ID
-	POST /account/authenticate - Authenticate a guest account 
-	POST /account/register - Register a new guest account 
-	POST /account/confirm-email - Confirm the email of a guest account 
-	GET /account - Retrieve account details
-	GET /backoffice/instructors - Retrieve all instructors 
-	POST /backoffice/instructors - Create a new instructor 
-	GET /backoffice/instructors/{id} - Retrieve a specific instructor by ID 
-	DELETE /backoffice/instructors/{id} - Delete a specific instructor by ID
-	IotCommunication: 
-	POST /communications/iot - Send an IoT communication
 

3 ОПИС РОЗРОБКИ IoT ЗАСТОСУНКУ
3.1 Концептуальне моделювання застосунку


Актором системи є користувач, який має можливість проводити конфігураційні налаштування параметрів комунікації з серверної частиною, параметрів Wi-Fi, запускати надсилання моніторингових даних на сервер.
Цикл роботи наступний (візуалізацію наведено в додатку А.2):
–	Після запуску програмного забеспечення проходить ініціалізація та запитування користувача про подальші дії.
–	Користувач може обрати налаштування конфігурації для зміни паролю Wi-Fi, SSID та інших системних даних, може змінити ідентифікатор регіону моніторингу.
–	Після налаштування, користувач може запустити моніторинговий процес з надсиланням інформації з датчиків на сервер.


3.2 Обгрунтування архітектурних рішень


Структура проекту включає в себе основний файл скрипту, "main.py", який є ядром системи моніторингу погоди. Використовуються додаткові модулі, такі як "urequests.py" та "ujson", щоб спростити HTTP-запити. Основний скрипт оркеструє функціональні можливості системи, включаючи збір даних з датчиків, обчислення індексу небезпеки та передачу даних на сервер бекенду.
Отже, на основі описаних архітектурних рішень отримуємо наступну UML діаграму діяльності (рис. А.5).
 
3.3 Опис використаних технологій


Система використовує мікроконтролер ESP32 для вимірювання умов середовища за допомогою датчика DHT22 (рис. А.7), який надає інформацію про температуру та вологість. За не наявності реального мікроконтролера, було використано симулятор Wokwi. Симулятор не підтримує зчитування даних про тиск, отже система імітує атмосферний тиск за допомогою функції нормального розподілу для генерації адекватних значень. Система розраховує індекси небезпеки для ожеледиці, вітру та снігу на основі показань датчиків і даних тиску, класифікуючи рівень небезпеки за категоріями. Мікроконтролер підключається до Wi-Fi, щоб надсилати зібрані дані та аналіз на серверну частину через запити HTTP POST, включаючи метадані та маркер авторизації для безпечного зв’язку. Система постійно відстежує та повідомляє про погодні умови, забезпечуючи своєчасне сповіщення про виняткові погодні умови.


3.4 Опис результатів розробки застосунку


Було розроблено рішення системи моніторингу погоди для вимірювання умов навколишнього середовища за допомогою мікроконтролера ESP32 і датчика DHT22. Основні функціональні можливості системи розширено структурованою службою ConfigurationService, яка централізує та керує критично важливими налаштуваннями для мережі, внутрішнього зв’язку та параметрів моделювання. Демонстративна ілюстрація структури проекту наведена в UML діаграмі взаємодії (рис. А.6).


4 ОПИС РОЗРОБКИ ВЕБ КЛІЄНТСЬКОЇ ЧАСТИНИ СИСТЕМИ
4.1 Концептуальне моделювання застосунку


Веб застосунок виступає в ролі адміністративної одиниці для адміністраторів та інструкторів. Адміністратори можуть додавати нових інструкторів, можуть додавати, видаляти та оновлювати інформацію про траси, тренування а також переглядати інформацію про букінги.


4.2 Обгрунтування архітектурних рішень


Клієнтський додаток було побудовано за допомогою компонентної архітектури, така архітектура є розповсюдженою при використанні фреймворків таких як Angular або React. Ідея полягає в тому, що застосунок поділено на логічні частини, які називаються компонентами, ці компоненти виступають як в ролі самостійних частин додатку, так і в ролі спільних, які перевикористовуються в різних частинах додатку в схожих контекстах.
	Додаток авторизує користувача за допомогою Identity Token, який містить метадані про природу токену, аксес токен або токен для доступу до ресурсів і рефреш токен, який використовується в випадку втрати дійсності звичайного аксес токену для перегенерування нового без переривань. Для реалізації використовувались звичайні можливості мови TypeScript і клієнту, айдентіті токен отримується з серверу та зберігається в локальному сховищі клієнта. 

 
4.3 Опис використаних технологій


Розробку вебклієнту було проведено за допомогою фреймворку Angular, мови програмування TypeScript. Бібліотека для стилів та розповсюджених компонентів було обрано Angular Material, яка легко інтегрується в код додатку та легко налаштовується.


4.4 Опис результатів розробки клієнтської частини системи


Результатом розробки став застосунок для вебклієнту.
На головній сторінці можна побачити загальну інформацію про курорт. Також є сторінки з детальним описом та контактами. 
Для того, щоб попасти на адміністративну частину додотку, треба перейти по спеціальному захищему маршруту, додаток перевірить чи є в клієнта достатньо прав та чи є токен доступу до ресурсів, в негативному випадку відкриється сторінка для аунтефікації. 
Після процесу аунтефікації буде відкрито сторінку дашборду зі списком доступним компонентів дашборду, бронювання, траси, інструктори, тренування.


4.5 Опис результатів тестування клієнтської частини системи


Тестування системи проводилось вручну за допомогою вбудованих утиліт браузера, логування і можливостей середовищ розробки, такі як телеметрія, перехоплення помилок і інші.


5 ОПИС РОЗРОБКИ МОБІЛЬНОЇ ЧАСТИНИ СИСТЕМИ
5.1 Концептуальне моделювання застосунку


Мобільний застосунок було розроблено для використання звичайними клієнтами гірськолижного курорту. Отже, головним функціоналом є можливість перегляду авторизованим користувачем доступних тренувань а також можливість бронювання.


5.2 Обгрунтування архітектурних рішень


За архітектуру мобільного додатку було обрано архітектуру MVVM (Model View ViewModel). Дана архітектура є розповсюдженою для розробки клієнтських додатків на персональні комп’ютери і мобільні телефони через її доречність і інтегрованість в можливості розробки на девайси.
Проект розбито за термінологією через не занадто великий обсяг мобільного додатку і в такому випадку орієнтуватись по термінах простіше ніж по компонентах, тому що уникається проблема великого гніздування з невеликою кількістю файлів.
Кожна логічна частина додатку представлено в вигляді моделі, представлення, моделі представлення та тіньового коду представлення.
Для зручності керування сервісами було використано можливості контейнеру залежностей фреймворку MAUI. Головна сторінка була зареєстрована як сінглтон, інші сторінки та сервіси мають перехідний життєвий цикл через позбавлення будь якого стану що позитивно сказується на об’єм використання пам’яті додатком та його швидкодії.
Обмін інформацією між сервером та додатком виконується за допомогою фабрики хттп клієнтів, які пов’язуються за типом з сервісом який його використовує і асинхроних методів сервісу.
Авторизація відбувається за допомогою Identity token, який зберігається в безпечному шифрованому сховищі додатку.


5.3 Опис використаних технологій


Застосунок розроблено за допомогою мови C# та фреймворка MAUI (Muti-Platform App UI). Для реалізації паттерну MVVM було використано пакет розширень MAUI Community Toolkit MVVM від громади користувачів фреймворку. Для візуального рендеру було використано технологію XAML, побудованої на мові розмітки XML, яка інтегрується з тіньовим кодом сторінки і забезпечує одностороннє та двохстороннє зв’язування інформації з коду та з представлення.


5.4 Опис результатів розробки мобільного застосунку


Результатом розробки став мобільний застосунок.
Головна сторінка представлена переліком всіх тренувань в  режимі прокручування та захищена авторизацією. Якщо користувач не аунтефікован, головна сторінка перенаправить користувача на сторінку аунтефікації. Після аунтефікації користувач може переглядати доступні тренування, може переглянути деталі тренування натиснувши на кнопку в відповідній карточці тренування. На сторінці детального перегляду користувач може переглянути більш детальну інформацію про тренування, повернутись назад на головну сторінку або забронювати місце на тренуванні. Якщо воно вже заброньовано користувачем, буде виведено повідомлення і кнопку бронювання буде вимкнено. В разі успішного бронювання буде виведене повідомлення про успішне бронювання з вказанням ідентифікатору бронювання.


5.5 Опис результатів тестування клієнтської частини системи


Тестування системи проводилось вручну за допомогою вбудованих утиліт браузера, логування і можливостей середовищ розробки, такі як телеметрія, перехоплення помилок і інші.

 
ВИСНОВКИ


Під час реалізації даного проєкту було проведено всебічний аналіз бізнес-процесів та визначено основні вимоги до функціональності системи, що мала на меті забезпечити ефективне управління даними через REST API. Було виявлено ключові потреби користувачів та сформульовано чіткі критерії до проектування маршрутизації, що забезпечує структуровану та гнучку роботу з ресурсами. Дослідження аналогічних систем дозволило визначити оптимальні підходи для реалізації стабільної та розширюваної архітектури.
На етапі розробки було створено концептуальну модель взаємодії між компонентами, що дозволило інтегрувати логіку маршрутизації відповідно до вимог. Проектування ґрунтувалося на принципах модульності та розширюваності, що забезпечує зручне масштабування і подальше впровадження нових функцій. Застосування таких технологій, як ASP.NET Core для серверної частини, Angular для клієнтського інтерфейсу, а також MAUI для кросплатформеного мобільного застосунку, сприяло створенню комплексного рішення. Додатково було використано Wokwi для прототипування вбудованих систем, що дозволило забезпечити інтеграцію IoT-складової.
Завдяки використанню сучасних підходів та інструментів вдалося створити систему, яка відповідає вимогам щодо продуктивності, гнучкості та зручності підтримки. Реалізоване рішення демонструє високий рівень узгодженості між компонентами та забезпечує ефективну інтеграцію з іншими сервісами, що підтверджує доцільність обраних архітектурних рішень та технологій.


ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ


1.	Загальна інформація. URL: https://skimis.at/ski-resort-management/ (дата звернення: 15.04.2024)
2.	Репозиторій проекту. URL: https://github.com/NureTkachenkoMykhailo/apzkr-pzpi-21-2-tkachenko-mykhailo (дата звернення: 22.08.2024)
3.	Емулятор ІоТ девайсу. Wokwi. URL: https://wokwi.com/projects/398059490999458817 (дата звернення: 09.06.2024).
4.	Документація ASP.NET. Microsoft learn. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 20.05.2024).
5.	Документація Angular. Angular. URL: https://angular.dev/ (дата звернення: 22.07.2024).
6.	Документація Wokwi. Wokwi Docs. URL: https://docs.wokwi.com/ (дата звернення: 22.05.2024).
7.	Документація .NET Multi-platform App UI. Microsoft Learn. URL: https://learn.microsoft.com/en-us/dotnet/maui/?view=net-maui-8.0 (date of access: 18.08.2024).

ДОДАТОК А
Діаграми

А.1 UML діаграма прецедентів

 
А.2 ER-модель даних

 
А.3 UML діаграма розгортання

 
А.4 Діаграма пакетів

 
А.5 UML діаграма діяльності IoT девайсу

 
А.6 Діаграма взаємодії

 
А.7 Схема фізичної моделі IoT девайсу
 
 
ДОДАТОК Б
Фрагменти коду програми


Б.1 Стартовий файл серверної частини


     1	using SnowWarden.Backend.API.Extensions.DI;
     2	using SnowWarden.Backend.API.Extensions.WebApp;
     3	using SnowWarden.Backend.Application.Extensions.DI;
     4	using SnowWarden.Backend.Infrastructure.Extensions.DI;
     5	
     6	WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
     7	
     8	builder.Services.ConfigureApplicationOptions(builder.Configuration);
     9	builder.Services.ConfigureApplicationSwagger();
    10	
    11	builder.Services.AddControllers();
    12	builder.Services.AddEndpointsApiExplorer();
    13	builder.Services.AddMapping();
    14	builder.Services.AddApplicationIdentities();
    15	builder.Services.AddApplicationAuthentication(builder.Configuration);
    16	builder.Services.AddEventProcessor();
    17	builder.Services.AddApplicationLayer();
    18	builder.Services.AddInfrastructureLayer(builder.Configuration);
    19	builder.Services.AddReserveCoping();
    20	
    21	builder.Services.AddCors(options =>
    22	{
    23	    options.AddPolicy("AllowAll", policy =>
    24	    {
    25	       policy.AllowAnyOrigin()
    26	          .AllowAnyMethod()
    27	          .AllowAnyHeader();
    28	    });
    29	});
    30	
    31	WebApplication app = builder.Build();
    32	
    33	// Застосувати міграції, які ще не були застосовані до актуальної схеми
    34	app.UseDatabaseMigrations();
    35	
    36	if (app.Environment.IsDevelopment())
    37	{
    38	    app.UseSwagger();
    39	    app.UseSwaggerUI();
    40	}
    41	
    42	app.UseHttpsRedirection();
    43	app.UseCors("AllowAll");
    44	
    45	app.UseAuthentication();
    46	app.UseAuthorization();
    47	
    48	app.MapControllers();
    49	
    50	await app.SeedMembers();
    51	
    52	app.Run();


Б.2 Код сервісу IdentityService


     1	using Microsoft.AspNetCore.Identity;
     2	
     3	using SnowWarden.Backend.Core.Exceptions;
     4	using SnowWarden.Backend.Core.Features.Identity;
     5	using SnowWarden.Backend.Core.Features.Identity.Services;
     6	
     7	using SnowWarden.Backend.Core.Utils.Localization;
     8	using SnowWarden.Backend.Core.Utils.Localization.Services;
     9	using SnowWarden.Backend.Core.Utils.Results;
    10	
    11	namespace SnowWarden.Backend.Infrastructure.Services;
    12	
    13	public class IdentityService<TUser> : IIdentityService<TUser> where TUser : ApplicationUser, new()
    14	{
    15	    private readonly IApplicationUserManager<TUser> _memberManager;
    16	
    17	    public IdentityService(IApplicationUserManager<TUser> memberManager)
    18	    {
    19	       _memberManager = memberManager;
    20	    }
    21	
    22	    public async Task<ApplicationIdentityResult<TUser>> SignIn(string contact, string password)
    23	    {
    24	       ApplicationIdentityResult<TUser> searchIdentityResult = await FindAsync(contact);
    25	       if (!searchIdentityResult.Succeeded)
    26	          return ApplicationIdentityResult<TUser>.Failure(
    27	             type: IdentityResultType.InvalidContact,
    28	             errors: [
    29	                new LocalizedContent
    30	                {
    31	                   Translations = new LocalizationDictionary
    32	                   {
    33	                      {Localizator.SupportedLanguages.AmericanEnglish, "User provided incorrect credentials"},
    34	                      {Localizator.SupportedLanguages.Ukrainian, "Користувач ввів неправильні дані"}
    35	                   }
    36	                }
    37	             ]);
    38	       TUser foundUser = searchIdentityResult.User!;
    39	
    40	       bool isEmailConfirmed = foundUser.EmailConfirmed;
    41	       bool isLockedOut = await _memberManager.IsLockedOutAsync(foundUser);
    42	       bool passwordValid = await _memberManager.CheckPasswordAsync(foundUser, password);
    43	
    44	       if (!isEmailConfirmed)
    45	       {
    46	          return ApplicationIdentityResult<TUser>.Failure(
    47	             type: IdentityResultType.EmailNotConfirmed,
    48	             errors: [
    49	                new LocalizedContent
    50	                {
    51	                   Translations = new LocalizationDictionary
    52	                   {
    53	                      {Localizator.SupportedLanguages.AmericanEnglish, $"User {contact} has not confirmed email yet" },
    54	                      {Localizator.SupportedLanguages.Ukrainian, $"Користувач {contact} ще не підтвердив свою пошту" }
    55	                   }
    56	                }
    57	             ]);
    58	       }
    59	
    60	       if (isLockedOut)
    61	       {
    62	          return ApplicationIdentityResult<TUser>.Failure(
    63	             type: IdentityResultType.LockedOut,
    64	             errors: [
    65	                new LocalizedContent
    66	                {
    67	                   Translations = new LocalizationDictionary
    68	                   {
    69	                      {Localizator.SupportedLanguages.AmericanEnglish, $"User with contact {contact} exists, but it is being under lockout"},
    70	                      {Localizator.SupportedLanguages.Ukrainian, $"Користувач з контактною інформацією {contact} існує, але діє локдаун"}
    71	                   }
    72	                }
    73	             ]);
    74	       }
    75	
    76	       if (!passwordValid)
    77	       {
    78	          return ApplicationIdentityResult<TUser>.Failure(
    79	             type: IdentityResultType.InvalidPassword,
    80	             errors: [
    81	                new LocalizedContent
    82	                {
    83	                   Translations = new LocalizationDictionary
    84	                   {
    85	                      {Localizator.SupportedLanguages.AmericanEnglish, "User provided incorrect credentials"},
    86	                      {Localizator.SupportedLanguages.Ukrainian, "Користувач ввів неправильні дані"}
    87	                   }
    88	                }
    89	             ]);
    90	       }
    91	
    92	       return ApplicationIdentityResult<TUser>
    93	          .Successful(
    94	             type: IdentityResultType.Valid,
    95	             user: foundUser);
    96	    }
    97	    public async Task<ApplicationIdentityResult<TUser>> Register(TUser user, string password)
    98	    {
    99	       IdentityResult identityResult = await _memberManager.CreateAsync(user, password);
   100	
   101	       if (!identityResult.Succeeded)
   102	       {
   103	          ApplicationIdentityResult<TUser>
   104	             .Failure(
   105	                IdentityResultType.Invalid,
   106	                errors:
   107	                [
   108	                   new LocalizedContent
   109	                   {
   110	                      Translations = new LocalizationDictionary
   111	                      {
   112	                         {
   113	                            Localizator.SupportedLanguages.AmericanEnglish,
   114	                            "User provided incorrect credentials"
   115	                         },
   116	                         {
   117	                            Localizator.SupportedLanguages.Ukrainian,
   118	                            "Користувач ввів неправильні дані"
   119	                         }
   120	                      }
   121	                   }
   122	                ]);
   123	       }
   124	
   125	       TUser registered = await _memberManager.FindByEmailAsync(user.Email ?? string.Empty) ?? throw new LocalizedException(
   126	          new LocalizedContent
   127	          {
   128	             Translations = new LocalizationDictionary
   129	             {
   130	                {
   131	                   Localizator.SupportedLanguages.AmericanEnglish,
   132	                   "Registration operation has failed, try again"
   133	                },
   134	                {
   135	                   Localizator.SupportedLanguages.Ukrainian,
   136	                   "Не вдалось зареєструвати користувача, спробуйте ще раз"
   137	                }
   138	             }
   139	          });
   140	
   141	       return ApplicationIdentityResult<TUser>.Successful(
   142	          type: IdentityResultType.Valid,
   143	          user: registered);
   144	    }
   145	
   146	    public async Task<ApplicationIdentityResult<TUser>> RegisterWithTemporaryPassword(TUser user)
   147	    {
   148	       IdentityResult result = await _memberManager.CreateWithTemporaryPasswordAsync(user, 8);
   149	       LocalizedException exception = new(
   150	          new LocalizedContent
   151	          {
   152	             Translations = new LocalizationDictionary
   153	             {
   154	                {
   155	                   Localizator.SupportedLanguages.AmericanEnglish,
   156	                   "Registration operation has failed, try again"
   157	                },
   158	                {
   159	                   Localizator.SupportedLanguages.Ukrainian,
   160	                   "Не вдалось зареєструвати користувача, спробуйте ще раз"
   161	                }
   162	             }
   163	          });
   164	
   165	       if (!result.Succeeded) throw exception;
   166	
   167	       TUser registered = await _memberManager.FindByEmailAsync(user.Email ?? string.Empty) ?? throw exception;
   168	
   169	       return ApplicationIdentityResult<TUser>.Successful(
   170	          type: IdentityResultType.Valid,
   171	          user: registered);
   172	    }
   173	
   174	    public async Task<ApplicationIdentityResult<TUser>> ConfirmEmail(int userId, string token)
   175	    {
   176	       TUser? foundGuest = await _memberManager.FindByIdAsync(userId.ToString());
   177	
   178	       if (foundGuest is null)
   179	       {
   180	          return ApplicationIdentityResult<TUser>.Failure(IdentityResultType.InvalidContact,
   181	             errors: [
   182	                new LocalizedContent
   183	                {
   184	                   Translations = new LocalizationDictionary
   185	                   {
   186	                      {Localizator.SupportedLanguages.AmericanEnglish, "User was not found"},
   187	                      {Localizator.SupportedLanguages.Ukrainian, "Користувача не знайдено"}
   188	                   }
   189	                }
   190	             ]);
   191	       }
   192	
   193	       IdentityResult identityResult = await _memberManager.ConfirmEmailAsync(foundGuest, token);
   194	       if (!identityResult.Succeeded)
   195	       {
   196	          return ApplicationIdentityResult<TUser>
   197	             .Failure(
   198	                type: IdentityResultType.Invalid,
   199	                errors:
   200	                [
   201	                   new LocalizedContent
   202	                   {
   203	                      Translations = new LocalizationDictionary
   204	                      {
   205	                         {
   206	                            Localizator.SupportedLanguages.AmericanEnglish,
   207	                            "User provided incorrect token or id"
   208	                         },
   209	                         { Localizator.SupportedLanguages.Ukrainian, "Користувач ввів неправильний токен або ідентифікатор" }
   210	                      }
   211	                   }
   212	                ]);
   213	       }
   214	
   215	       return ApplicationIdentityResult<TUser>.Successful(IdentityResultType.Valid);
   216	    }
   217	    public async Task<ApplicationIdentityResult<TUser>> UpdateAsync(TUser user)
   218	    {
   219	       TUser? foundUser = await _memberManager.FindByIdAsync(user.Id.ToString());
   220	       if (foundUser is null)
   221	       {
   222	          return ApplicationIdentityResult<TUser>.Failure(IdentityResultType.InvalidContact, errors:
   223	          [
   224	             new LocalizedContent
   225	             {
   226	                Translations = new LocalizationDictionary
   227	                {
   228	                   { Localizator.SupportedLanguages.AmericanEnglish, "Invalid user for update" },
   229	                   {
   230	                      Localizator.SupportedLanguages.Ukrainian,
   231	                      "Не вдалось оновити дані користувача, спробуйте ще раз"
   232	                   }
   233	                }
   234	             }
   235	          ]);
   236	       }
   237	
   238	       await _memberManager.UpdateAsync(foundUser);
   239	
   240	       return ApplicationIdentityResult<TUser>.Successful(IdentityResultType.Valid, foundUser);
   241	    }
   242	    public async Task<ApplicationIdentityResult<TUser>> FindAsync(string contact)
   243	    {
   244	       TUser? foundUser = await _memberManager.FindByEmailAsync(contact) ?? await _memberManager.FindByNameAsync(contact);
   245	
   246	       if (foundUser is null)
   247	       {
   248	          return ApplicationIdentityResult<TUser>.Failure(
   249	             type: IdentityResultType.InvalidContact,
   250	             errors: [
   251	                new LocalizedContent
   252	                {
   253	                   Translations = new LocalizationDictionary
   254	                   {
   255	                      {Localizator.SupportedLanguages.AmericanEnglish, $"User with contact {contact} does not exist"},
   256	                      {Localizator.SupportedLanguages.Ukrainian, $"Користувач з контактною інформацією {contact} не існує"}
   257	                   }
   258	                }
   259	             ]);
   260	       }
   261	
   262	       return ApplicationIdentityResult<TUser>.Successful(IdentityResultType.Valid, foundUser);
   263	    }
   264	}


Б.3 Код базового репозиторію


     1 using System.Linq.Expressions;
     2	
     3	using Microsoft.EntityFrameworkCore;
     4	using Microsoft.EntityFrameworkCore.ChangeTracking;
     5	
     6	using SnowWarden.Backend.Core.Abstractions;
     7	using SnowWarden.Backend.Core.Utils.Localization;
     8	using SnowWarden.Backend.Core.Utils.Localization.Services;
     9	
    10	using SnowWarden.Backend.Infrastructure.Data;
    11	using SnowWarden.Backend.Infrastructure.Exceptions;
    12	using SnowWarden.Backend.Infrastructure.Services;
    13	
    14	namespace SnowWarden.Backend.Infrastructure.Repositories;
    15	
    16	public abstract class RepositoryBase<TEntity> : IRepository<TEntity> where TEntity : class, IDbEntity
    17	{
    18	    protected readonly ApplicationDbContext Context;
    19	    protected readonly AttachMaster AttachMaster;
    20	
    21	    protected RepositoryBase(ApplicationDbContext context, AttachMaster attachMaster)
    22	    {
    23	       Context = context;
    24	       AttachMaster = attachMaster;
    25	    }
    26	
    27	    public async Task<ICollection<TEntity>> CreateRange(params TEntity[] entities)
    28	    {
    29	       foreach (TEntity entity in entities)
    30	       {
    31	          await CreateInternalAsync(entity);
    32	          Context.Set<TEntity>().Add(entity);
    33	       }
    34	
    35	       await Context.SaveChangesAsync();
    36	
    37	       return entities;
    38	    }
    39	    public async Task<TEntity> CreateAsync(TEntity entity)
    40	    {
    41	       await CreateInternalAsync(entity);
    42	       Context.Set<TEntity>().Add(entity);
    43	       await Context.SaveChangesAsync();
    44	
    45	       return entity;
    46	    }
    47	    public async Task<TEntity> UpdateAsync(TEntity entity)
    48	    {
    49	       TEntity source = await IncludeComplete(Context.Set<TEntity>()).FirstOrDefaultAsync(e => e.Id == entity.Id)
    50	          ?? throw new InfrastructureException(new LocalizedContent
    51	          {
    52	             Translations = new LocalizationDictionary
    53	             {
    54	                {
    55	                   Localizator.SupportedLanguages.AmericanEnglish,
    56	                   $"Could not find entity {typeof(TEntity).Name} to update with id {entity.Id}"
    57	                },
    58	                {
    59	                   Localizator.SupportedLanguages.Ukrainian,
    60	                   $"Не вийшло знайти сутність {typeof(TEntity).Name} з ідентифікатором {entity.Id}"
    61	                }
    62	             }
    63	          });
    64	
    65	       Context.Entry(source).CurrentValues.SetValues(entity);
    66	       await UpdateInternalAsync(source, entity);
    67	       Context.Update(source);
    68	       await Context.SaveChangesAsync();
    69	
    70	       return source;
    71	    }
    72	    public async Task<TEntity> DeleteAsync(TEntity entity)
    73	    {
    74	       EntityEntry<TEntity> removed = Context.Set<TEntity>().Remove(entity);
    75	       await Context.SaveChangesAsync();
    76	
    77	       return removed.Entity;
    78	    }
    79	    public async Task<TEntity> DeleteByIdAsync(int id)
    80	    {
    81	       TEntity? entity = await Context.Set<TEntity>().FindAsync(id);
    82	       Context.Set<TEntity>().Remove(entity);
    83	
    84	       await Context.SaveChangesAsync();
    85	
    86	       return entity;
    87	    }
    88	
    89	    public async Task<TEntity?> GetReadonlyByIdCompleteAsync(int id) =>
    90	       await IncludeComplete(Context.Set<TEntity>()).AsNoTracking().FirstOrDefaultAsync(e => e.Id == id);
    91	    public async Task<TEntity?> GetByIdAsync(int id) =>
    92	       await IncludeLightweight(Context.Set<TEntity>()).FirstOrDefaultAsync(e => e.Id == id);
    93	    public async Task<TEntity?> GetByIdCompleteAsync(int id) =>
    94	       await IncludeComplete(Context.Set<TEntity>()).FirstOrDefaultAsync(e => e.Id == id);
    95	
    96	    public async Task<IReadOnlyCollection<TEntity>> GetReadonlyCompleteAsync(Expression<Func<TEntity, bool>> predicate) =>
    97	       await IncludeComplete(Context.Set<TEntity>()).AsNoTracking().Where(predicate).ToListAsync();
    98	    public async Task<IReadOnlyCollection<TEntity>> GetReadonlyLightweightAsync(Expression<Func<TEntity, bool>> predicate) =>
    99	       await IncludeLightweight(Context.Set<TEntity>()).AsNoTracking().Where(predicate).ToListAsync();
   100	    public async Task<IReadOnlyCollection<TEntity>> GetReadonlyCompleteAsync() =>
   101	       await IncludeComplete(Context.Set<TEntity>()).AsNoTracking().ToListAsync();
   102	    public async Task<IReadOnlyCollection<TEntity>> GetReadonlyLightweightAsync() =>
   103	       await IncludeLightweight(Context.Set<TEntity>()).AsNoTracking().ToListAsync();
   104	    public Task<List<TEntity>> GetCompleteAsync(Expression<Func<TEntity, bool>> predicate) =>
   105	       IncludeComplete(Context.Set<TEntity>()).Where(predicate).ToListAsync();
   106	    public Task<List<TEntity>> GetCompleteAsync() => IncludeComplete(Context.Set<TEntity>()).ToListAsync();
   107	    public Task<List<TEntity>> GetLightweightAsync() =>
   108	       IncludeLightweight(Context.Set<TEntity>()).ToListAsync();
   109	    public Task<List<TEntity>> GetLightweightAsync(Expression<Func<TEntity, bool>> predicate) =>
   110	       IncludeLightweight(Context.Set<TEntity>()).Where(predicate).ToListAsync();
   111	
   112	    protected abstract Task UpdateInternalAsync(TEntity source, TEntity compare);
   113	    protected abstract Task CreateInternalAsync(TEntity addedEntity);
   114	
   115	    protected abstract IQueryable<TEntity> IncludeComplete(DbSet<TEntity> set);
   116	    protected abstract IQueryable<TEntity> IncludeLightweight(DbSet<TEntity> set);
   117	
   118	    protected virtual async Task ValidateSingleAttachment<TAttachment>(
   119	        TEntity source, Func<TEntity, TAttachment?> validationDelegate,
   120	        Func<TEntity, int> foreignKeySelector)
   121	        where TAttachment : class, IDbEntity, new()
   122	    {
   123	       TAttachment? attachment = validationDelegate(source);
   124	       if (attachment is null)
   125	       {
   126	          attachment = new TAttachment();
   127	          attachment.SetExistingId(foreignKeySelector(source));
   128	       }
   129	       _ = await Context.Set<TAttachment>().FindAsync(attachment.Id)
   130	          ?? throw new InvalidAttachmentEntityException(attachment);
   131	    }
   132	
   133	    protected virtual async Task ValidateManyAttachments<TAttachment>(TEntity source, Func<TEntity, ICollection<TAttachment>> validationDelegate) where TAttachment : class, IDbEntity
   134	    {
   135	       ICollection<TAttachment> attachments = validationDelegate(source);
   136	       List<TAttachment> dbAttachments = await Context.Set<TAttachment>().ToListAsync();
   137	       foreach (TAttachment attachment in attachments)
   138	       {
   139	          if (dbAttachments.Select(da => da.Id).Contains(attachment.Id) is false)
   140	          {
   141	             throw new InvalidAttachmentEntityException(attachment);
   142	          }
   143	       }
   144	    }
   145	}


Б.4 Код ініціалізації IoT девайсу


     1	def main_loop():
     2	    network_service = NetworkService()
     3	    sta_if = network_service.connect_to_wifi(
     4	        ConfigurationService.Networking.SSID_NAME, 
     5	        ConfigurationService.Networking.PASSWORD)
     6	
     7	    data_service = HazardService()
     8	    last_pressure = MathService.normal_distribution(
     9	        ConfigurationService.Simulation.Pressure.DEFAULT_PRESSURE, 
    10	        ConfigurationService.Simulation.Pressure.DEFAULT_DISTRIBUTION)
    11	
    12	    while True:
    13	        try:
    14	            print("Measuring weather conditions... ", end="")
    15	            temperature, humidity, current_pressure = data_service.read_sensors()
    16	            hazard_data = data_service.calculate_danger_index(temperature, humidity, current_pressure, last_pressure)
    17	            message_type = data_service.determine_message_type(hazard_data)
    18	            data = {
    19	                "trackSectionId": ConfigurationService.TRACK_SECTION_ID,
    20	                "messageType": message_type,
    21	                "message": "exceptional weather conditions detected" if message_type == 3 else "weather conditions warning" if message_type == 2 else "adequate weather conditions",
    22	                "metadata": {
    23	                    "wind": str(hazard_data["wind"]),
    24	                    "iciness": str(hazard_data["iciness"]),
    25	                    "snow": str(hazard_data["snow"])
    26	                }
    27	            }
    28	
    29	            headers = {
    30	                'Content-Type': 'application/json',
    31	                'Authorization': ConfigurationService.Communications.Backend.AUTH_TOKEN
    32	            }
    33	            response = urequests.post(
    34	                ConfigurationService.Communications.Backend.BACKEND_URL, 
    35	                data=ujson.dumps(data), 
    36	                headers=headers)
    37	            print("Posted to backend: ", response.text)
    38	            response.close()
    39	
    40	            last_pressure = current_pressure
    41	        except OSError as e:
    42	            print("Failed to send data: ", e)
    43	        
    44	        time.sleep(10)


Б.5 Конфігурація IoT девайсу


     1	class ConfigurationService:
     2	    class Communications:
     3	        class Backend:
     4	            BACKEND_URL = "http://localhost:7112/communications/iot"
     5	            AUTH_TOKEN = "362EA6716B524D718A65C30D7284A682"
     6	    class Simulation:
     7	        class Pressure:
     8	            DEFAULT_PRESSURE = 1015
     9	            DEFAULT_DISTRIBUTION = 5
    10	    class Networking:
    11	        SSID_NAME = 'Wokwi-GUEST'
    12	        PASSWORD = ''
    13	    TRACK_SECTION_ID = 5
    14	
    15	    @classmethod
    16	    def update_networking(cls, ssid_name, password):
    17	        cls.Networking.SSID_NAME = ssid_name
    18	        cls.Networking.PASSWORD = password
    19	
    20	    @classmethod
    21	    def update_backend(cls, backend_url, auth_token):
    22	        cls.Communications.Backend.BACKEND_URL = backend_url
    23	        cls.Communications.Backend.AUTH_TOKEN = auth_token
    24	
    25	    @classmethod
    26	    def update_track_section_id(cls, track_section_id):
    27	        cls.TRACK_SECTION_ID = track_section_id


Б.6 Код ініціалізації веб клієнту


     1	import { NgModule } from '@angular/core';
     2	import { BrowserModule } from '@angular/platform-browser';
      	
     3	import { AppRoutingModule } from './app-routing.module';
     4	import { AppComponent } from './app.component';
     5	import {SharedModule} from "./shared/shared.module";
     6	import {HttpClientModule} from "@angular/common/http";
     7	import {AuthService} from "./core/services/auth.service";
     8	import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
     9	import {MatDialogModule} from "@angular/material/dialog";
    10	import {MatNativeDateModule} from "@angular/material/core";
    11	@NgModule({
    12	  declarations: [
    13	    AppComponent
    14	  ],
    15	    imports: [
    16	        MatNativeDateModule,
    17	        BrowserModule,
    18	        AppRoutingModule,
    19	        SharedModule,
    20	        MatDialogModule,
    21	        HttpClientModule
    22	    ],
    23	  providers: [AuthService, provideAnimationsAsync()],
    24	  bootstrap: [AppComponent]
    25	})
    26	export class AppModule { }


Б.7 Код ініціалізації адміністративного модуля


     1	import { NgModule } from '@angular/core';
     2	import { CommonModule } from '@angular/common';
     3	import { BackofficeRoutingModule } from './backoffice-routing.module';
     4	import { BookingsComponent } from './dashboard/bookings/bookings.component';
     5	import { InstructorsComponent } from './dashboard/instructors/instructors.component';
     6	import { LoginComponent } from './login/login.component';
     7	import { ReactiveFormsModule } from "@angular/forms";
     8	import { DashboardComponent } from './dashboard/dashboard.component';
     9	import {SharedModule} from "../shared/shared.module";
    10	import { TracksComponent } from './dashboard/tracks/tracks.component';
    11	import { TrackDetailsDialogComponent } from './dashboard/tracks/track-details-dialog/track-details-dialog.component';
    12	import {MatDialogActions, MatDialogClose, MatDialogContent, MatDialogTitle} from "@angular/material/dialog";
    13	import {MatButton, MatFabButton} from "@angular/material/button";
    14	import { TrackDataDialogComponent } from './dashboard/tracks/track-data-dialog/track-data-dialog.component';
    15	import {MatFormField, MatFormFieldModule} from "@angular/material/form-field";
    16	import {MatInput} from "@angular/material/input";
    17	import {MatOption, MatSelect} from "@angular/material/select";
    18	import { TrainingsComponent } from './dashboard/trainings/trainings.component';
    19	import { TrainingDetailsDialogComponent } from './dashboard/trainings/training-details-dialog/training-details-dialog.component';
    20	import { TrainingsDataDialogComponent } from './dashboard/trainings/trainings-data-dialog/trainings-data-dialog.component';
    21	import {MatDatepicker, MatDatepickerInput, MatDatepickerToggle} from "@angular/material/datepicker";
      	
      	
    22	@NgModule({
    23	  declarations: [
    24	    BookingsComponent,
    25	    InstructorsComponent,
    26	    LoginComponent,
    27	    DashboardComponent,
    28	    TracksComponent,
    29	    TrackDetailsDialogComponent,
    30	    TrackDataDialogComponent,
    31	    TrainingsComponent,
    32	    TrainingDetailsDialogComponent,
    33	    TrainingsDataDialogComponent
    34	  ],
    35	  imports: [
    36	    MatFormFieldModule,
    37	    CommonModule,
    38	    BackofficeRoutingModule,
    39	    ReactiveFormsModule,
    40	    SharedModule,
    41	    MatDialogClose,
    42	    MatButton,
    43	    MatDialogTitle,
    44	    MatDialogContent,
    45	    MatDialogActions,
    46	    MatFabButton,
    47	    MatFormField,
    48	    MatInput,
    49	    MatSelect,
    50	    MatOption,
    51	    MatDatepickerToggle,
    52	    MatDatepickerInput,
    53	    MatDatepicker
    54	  ]
    55	})
    56	export class BackofficeModule { }
 
	Б.8 Код ініціалізації мобільного клієнту


     1	using Microsoft.Extensions.Logging;
     2	using SnowWardenMobile.Extensions;
     3	using SnowWardenMobile.ViewModels;
     4	using SnowWardenMobile.Views;
     5	namespace SnowWardenMobile;
     6	public static class MauiProgram
     7	{
     8		public static MauiApp CreateMauiApp()
     9		{
    10			MauiAppBuilder builder = MauiApp.CreateBuilder();
    11			builder
    12				.UseMauiApp<App>()
    13				.ConfigureFonts(fonts =>
    14				{
    15					fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
    16					fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
    17				});
    18			builder.Services.AddClientAuthenticationServices();
    19			builder.Services.AddTrainingSessionApiCallerService();
    20			builder.Services.AddBookingApiCallerService();
    21			builder.Services.AddSingleton<MainPage>();
    22			builder.Services.AddTransient<MainPageViewModel>();
    23			builder.Services.AddTransient<Login>();
    24			builder.Services.AddTransient<LoginViewModel>();
    25			builder.Services.AddTransient<TrainingDetails>();
    26			builder.Services.AddTransient<TrainingDetailsViewModel>();
    27			builder.Logging.AddDebug();
    28			return builder.Build();
    29		}
    30	}
 
Б.9 Код глобальних налаштувань мобільного застосунку

      1	using SnowWardenMobile.Views;
      2	namespace SnowWardenMobile;
      3	public static class Global
      4	{
      5		public const string API_BASE_URL = "http://localhost:5298/";
      6		public static class ApplicationRoutes
      7		{
      8			public const string MainPage = $"{nameof(MainPage)}";
      9			public const string LoginPage = $"{nameof(Login)}";
     10			public const string TrainingDetailsPage = $"{nameof(TrainingDetails)}";
     11		}
     12	}


Б.9 Код головної моделі


     1 using System.Collections.ObjectModel;
     2 using CommunityToolkit.Mvvm.ComponentModel;
     3 using CommunityToolkit.Mvvm.Input;
     4	using SnowWardenMobile.Abstractions.Services;
     5	using SnowWardenMobile.Models.Trainings;
     6	using SnowWardenMobile.Services;
     7	namespace SnowWardenMobile.ViewModels;
     8	public partial class MainPageViewModel : ObservableObject
     9	{
    10		private readonly ITrainingSessionService _trainingService;
    11		public ObservableCollection<TrainingSession> TrainingSessions { get; } = [];
    12		public MainPageViewModel() { }
    13		public MainPageViewModel(TrainingSessionService trainingService)
    14		{
    15			_trainingService = trainingService;
    16			LoadTrainingSessionsCommand = new AsyncRelayCommand(LoadTrainingSessionsAsync);
    17		}
    18		public IAsyncRelayCommand LoadTrainingSessionsCommand { get; }
    19		public async Task LoadTrainingSessionsAsync()
    20		{
    21			try
    22			{
    23				ICollection<TrainingSession> sessions = await _trainingService.GetTrainingSessionsAsync();
    24				if (TrainingSessions.Any())
    25				{
    26					sessions = TrainingSessions
    27						.Where(ts =>
    28							sessions
    29								.Select(s => s.Id)
    30								.Contains(ts.Id) is false)
    31						.ToList();
    32				}
      	
    33				foreach (TrainingSession session in sessions)
    34				{
    35					TrainingSessions.Add(session);
    36				}
    37			}
    38			catch (TrainingSessionService.GetTrainingSessionsRequestFailedException ex)
    39			{
    40				await Application.Current.MainPage.DisplayAlert($"Fetch error", ex.Message, "OK");
    41			}
    42		}
      	
    43		[RelayCommand]
    44		private async Task ViewTrainingDetailsAsync(TrainingSession? selectedSession)
    45		{
    46			if (selectedSession is not null)
    47			{
    48				Dictionary<string, object> navigationParameter = new()
    49				{
    50					{ "SelectedSession", selectedSession }
    51				};
    52				await Shell.Current.GoToAsync(Global.ApplicationRoutes.TrainingDetailsPage, navigationParameter);
    53			}
